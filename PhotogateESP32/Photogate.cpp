#include "Photogate.h"


Photogate::Photogate(const unsigned int* gate) : _gate(gate), _gateSize(s_gateSize), _isRunning(true)
{
  _TimeStamps = new TimeStamps();

  for(int i = 0; i < _gateSize; i++)
  {
    _Channel[i] = new Channel(i, _gate[i]);
  }

  Adafruit_SSD1306 OLED = Adafruit_SSD1306(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

}


Photogate::~Photogate()
{
  for(int i = 0; i < _gateSize; i++) {
        delete _Channel[i];
    }
    delete[] _Channel;
    delete _TimeStamps;
}


void Photogate::PinSetGate()
{
  for(int index = 0; index < 6; index++) {pinMode(_gate[index], INPUT);} // Change INPUT_PULLUP to INPUT later, check results.
  // INPUT_PULLUP: 4095 when no light is detected (must use a resistor connected to VCC, otherwise it might not work if not using devboards)
  // INPUT: 4095 when all light is detected
}
  
void Photogate::InitOLED()
{
  // initialize the OLED object
  if(!OLED.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS)) {
    Serial.println(F("SSD1306 allocation failed"));
    for(;;); // Don't proceed, loop forever
  }

    // BITMAP IMAGES (Generated on https://javl.github.io/image2cpp/, at 02/03/2025, 22:34)

// 'ufscar_logo_128x32', 128x32px
const unsigned char epd_bitmap_ufscar_logo_128x32 [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x06, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x06, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x06, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x06, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x81, 0xf8, 0x0c, 0x07, 0xfc, 0x07, 0xff, 0xc0, 0x07, 0xff, 0x80, 0x7c, 0x00, 0x01, 0xff, 
	0xff, 0x81, 0xf8, 0x1c, 0x07, 0xfc, 0x1f, 0xff, 0xf0, 0x1f, 0xff, 0xe0, 0xf8, 0x00, 0x01, 0xff, 
	0xff, 0x81, 0xf8, 0x1c, 0x07, 0xfc, 0x3f, 0xff, 0xf0, 0x3f, 0xff, 0xf0, 0xf8, 0x00, 0x01, 0xff, 
	0xff, 0x81, 0xf8, 0x1c, 0x07, 0xfc, 0x3f, 0x83, 0xf8, 0x3f, 0xcf, 0xf1, 0xf0, 0x00, 0x01, 0xff, 
	0xff, 0x81, 0xf8, 0x1c, 0x07, 0xfc, 0x3f, 0x83, 0xf8, 0x7f, 0x03, 0xf9, 0xe0, 0x00, 0x01, 0xff, 
	0xff, 0x81, 0xf8, 0x0c, 0x07, 0xfc, 0x3f, 0xf0, 0x00, 0x7f, 0x01, 0x83, 0xe0, 0x00, 0x01, 0xff, 
	0xff, 0x81, 0xf8, 0x00, 0x00, 0x1c, 0x3f, 0xff, 0x80, 0xfe, 0x00, 0x07, 0xc0, 0x00, 0x01, 0xff, 
	0xff, 0x81, 0xf8, 0x00, 0x00, 0x1c, 0x1f, 0xff, 0xe0, 0xfe, 0x00, 0x0f, 0x9f, 0x00, 0x03, 0xff, 
	0xff, 0x81, 0xf8, 0x00, 0x00, 0x1c, 0x07, 0xff, 0xf8, 0xfe, 0x00, 0x0f, 0xff, 0xe3, 0xff, 0xff, 
	0xff, 0x81, 0xf8, 0x00, 0x00, 0x1c, 0x00, 0xff, 0xf8, 0xfe, 0x00, 0x1f, 0xf9, 0xf3, 0xff, 0xff, 
	0xff, 0x80, 0xf0, 0x00, 0x00, 0x1c, 0x00, 0x07, 0xfc, 0x7e, 0x01, 0xfe, 0x01, 0xf3, 0xf3, 0xff, 
	0xff, 0x80, 0x00, 0x1c, 0x07, 0xfc, 0x7f, 0x01, 0xfc, 0x7f, 0x01, 0xfc, 0x1f, 0xf3, 0xe1, 0xff, 
	0xff, 0x80, 0x00, 0x1c, 0x07, 0xfc, 0x7f, 0x01, 0xfc, 0x7f, 0x03, 0xf8, 0xff, 0xf3, 0xe1, 0xff, 
	0xff, 0x80, 0x00, 0x1c, 0x07, 0xfc, 0x7f, 0x83, 0xf8, 0x3f, 0xff, 0xf9, 0xf1, 0xf3, 0xe1, 0xff, 
	0xff, 0xc0, 0x00, 0x1c, 0x07, 0xfc, 0x3f, 0xff, 0xf8, 0x1f, 0xff, 0xf1, 0xe3, 0xf3, 0xe1, 0xff, 
	0xff, 0xe0, 0x18, 0x1c, 0x07, 0xfc, 0x1f, 0xff, 0xf0, 0x0f, 0xff, 0xe1, 0xff, 0xf3, 0xe1, 0xff, 
	0xff, 0xf8, 0x7f, 0xfc, 0x07, 0xfe, 0x0f, 0xff, 0xe0, 0x0f, 0xff, 0xc1, 0xfe, 0xfb, 0xe3, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xfc, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};
// 'cca_logo_128x32', 128x32px
const unsigned char epd_bitmap_cca_logo_128x32 [] PROGMEM = {
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfb, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcf, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfd, 0xff, 0xff, 0xe0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xff, 0x80, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf9, 0xff, 0xfe, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xfc, 0xfc, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xfb, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xf7, 0xff, 0xc0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0xff, 0xef, 0xff, 0xe0, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xdf, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xdf, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf1, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x7f, 0xff, 0xff, 0xfe, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x3f, 0xff, 0xff, 0xfe, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x07, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x01, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x1f, 0xfb, 0xff, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x03, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x0f, 0xff, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x1f, 0xff, 0x9f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x7f, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x03, 0xff, 0xff, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff
};

  // Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 2080)
  const unsigned char* epd_bitmap_allArray[2] = {
        epd_bitmap_cca_logo_128x32,
        epd_bitmap_ufscar_logo_128x32
    };

  // Clear the buffer.
  OLED.clearDisplay();

  // Init logo images
  OLED.drawBitmap(0, 0,  epd_bitmap_allArray[0], 128, 64, WHITE);
  OLED.display();
  delay(2000);
  OLED.clearDisplay();
  OLED.drawBitmap(0, 0,  epd_bitmap_allArray[1], 128, 64, WHITE); 
  OLED.display();
  delay(2000);
  OLED.clearDisplay();
  OLED.display();
}


void Photogate::InitPhotogate() //Called when init button is pressed.
{
  // Start counting, call timestamps.
  // Change _isRunning status.
  _isRunning = true;
}

void Photogate::OnUpdate() // If read starts, should use this function to get time and analog data. (if using lm393, should get digital data).
{

  _TimeStamps->SetTime();
  unsigned long riseTime[s_gateSize] = {0};
  unsigned long fallTime[s_gateSize] = {0};
  bool rise[s_gateSize] = {false};
  bool fall[s_gateSize] = {false};
  unsigned int t_Read[s_gateSize] = {0};

  while(Serial.available() == 0)
  {

    OLED.clearDisplay();
    OLED.setTextSize(1);
    OLED.setTextColor(WHITE);
    OLED.setCursor(0,0);

    for(int index = 0; index<s_gateSize; index++)
    {
      t_Read[index] = _Channel[index]->Read();
      if(_Channel[index]->ShouldGetTimeStampUP())
      {
        _Channel[index]->SetStampUP(false);

        riseTime[index] = _TimeStamps->GetDeltaTime();
        Serial.print("Rise time:"); Serial.println(riseTime[index]);
      }

      if(_Channel[index]->ShouldGetTimeStampDOWN())
      {
        _Channel[index]->SetStampDOWN(false);

        fallTime[index] = _TimeStamps->GetDeltaTime();
        Serial.print("Fall time:"); Serial.println(fallTime[index]);

      }
      // OLED prints
      // if tab == 1:
      OLED.print("Channel "); OLED.print(index+1); OLED.print(": "); OLED.println(t_Read[index]);

      // if tab == 2:
      //OLED.print("R/F "); OLED.print(index+1); OLED.print(": "); OLED.print(riseTime[index]/1000000); OLED.print(" s, "); OLED.print(fallTime[index]/1000000); OLED.println(" s");


      // TO DO LIST:
      // TAB SYSTEM THAT GIVES TO ME:
      // 1. ANALOG READING FROM CHANNELS; (done)
      // 2. RISE AND FALL TIME FROM EACH CHANNEL;
      // 3. AUTOMATIC ONE CHANNEL PENDULUM PERIOD (T) CALCULATION (ALWAYS FROM CHANNEL 1 AND STACKS FOR MULTIPLE READINGS);
      // 4. REFERENCE LEVELS FROM EACH CHANNEL.

      // FIRST BUTTOM SHOULD CHANGE BETWEEN TABS
      // SECCOND BUTTOM IS MEANT FOR USER ACTIONS:
      // 1. RESET RISE, FALL AND TIMING READINGS;
      // 2. RESET PENDULUM PERIOD READINGS
      // 3. CHANGE REFERENCE LEVELS;
      //  A. LONG PRESS TO MODIFY/SHORT PRESS TO SELECT BETWEEN CHANNELS;
      //  B. ONCE LONG PRESSED, FIRST BUTTOM CHANGES FUNCTIONALITY TO HELP CHANGING VALUES.
      }

    OLED.display();
    
    _TimeStamps->DeltaTime();

    for(int index = 0; index<s_gateSize; index++)
    {
      //Serial.write(t_Read[index]); // Writes analog reads on serial
      //Serial.print("Read Analog Port: "); Serial.print(index); Serial.print(t_Read[index]); Serial.print(",");


      // char strBuf[50];
      // sprintf(strBuf, "AnalogPort %d: ", index);
      // Serial.print(strBuf); Serial.print(t_Read[index]); Serial.print(",");
      
    }

    // Channel 0
    unsigned int Channel_0 = t_Read[0];
    Serial.print("Channel_0:"); Serial.println(Channel_0);


    //unsigned long t_dTime = _TimeStamps->GetDeltaTime();
    //Serial.write(t_dTime); // Writes deltaTime on serial
    //Serial.print("TimeStamp:"); Serial.print(t_dTime); Serial.println("us");
    
    delay(25); // debug purposes.
  }
}

