<!DOCTYPE html>
<html>
<head>
    <title>ESP32 Buffered Photogate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: sans-serif; }
        #status { font-weight: bold; padding: 5px; border-radius: 5px; }
        .connected { color: green; background-color: #e0ffe0; }
        .disconnected { color: red; background-color: #ffe0e0; }
        .connecting { color: orange; background-color: #fff0e0; }
        #dataOutput { margin-top: 10px; padding: 10px; border: 1px solid #ccc; height: 150px; overflow-y: scroll; font-family: monospace; white-space: pre; }
        #chartContainer { margin-top: 20px; max-width: 90vw; height: 300px; }
    </style>
    <!-- Inclua Chart.js via CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>

<h1>ESP32 Buffered Photogate Data</h1>
<p>Status: <span id="status" class="disconnected">Disconnected</span></p>
<button id="connectButton">Connect</button>
<button id="disconnectButton" disabled>Disconnect</button>

<h2>Live Chart (Last N Samples)</h2>
<div id="chartContainer">
    <canvas id="sensorChart"></canvas>
</div>

<h2>Received Data Chunks (Raw - First/Last Sample):</h2>
<div id="dataOutput">Waiting for data...</div>

<script>
    const statusElem = document.getElementById('status');
    const dataOutputElem = document.getElementById('dataOutput');
    const connectButton = document.getElementById('connectButton');
    const disconnectButton = document.getElementById('disconnectButton');
    const chartCanvas = document.getElementById('sensorChart');

    const esp32Ip = "192.168.4.1";
    const socketUrl = `ws://${esp32Ip}/ws`;

    let socket = null;
    let receivedChunks = 0;
    const MAX_LINES = 50;

    // --- Tamanho do Pacote Individual (DEVE corresponder à struct C++) ---
    const SINGLE_PACKET_SIZE = 16; // 6 * uint16 (2 bytes) + 1 * uint32 (4 bytes)

    // --- Configuração do Gráfico ---
    let sensorChart = null;
    const MAX_CHART_POINTS = 200; // Aumente se precisar de mais histórico com buffer
    let chartData = {
        labels: [],
        datasets: [
            { label: 's1', data: [], borderColor: 'red', tension: 0.1, pointRadius: 0 },
            { label: 's2', data: [], borderColor: 'green', tension: 0.1, pointRadius: 0 },
            { label: 's3', data: [], borderColor: 'blue', tension: 0.1, pointRadius: 0 },
            { label: 's4', data: [], borderColor: 'black', tension: 0.1, pointRadius: 0 },
            { label: 's5', data: [], borderColor: 'yellow', tension: 0.1, pointRadius: 0 },
            { label: 's6', data: [], borderColor: 'orange', tension: 0.1, pointRadius: 0 },
        ]
    };

    function updateStatus(message, statusClass) {
        statusElem.textContent = message;
        statusElem.className = statusClass;
    }

    function logData(text) {
        const lines = dataOutputElem.innerHTML.split('\n');
        while (lines.length >= MAX_LINES) { lines.shift(); }
        const timestamp = new Date().toLocaleTimeString();
        lines.push(`[${timestamp}] Chunk: ${text}`);
        dataOutputElem.innerHTML = lines.join('\n');
        dataOutputElem.scrollTop = dataOutputElem.scrollHeight;
    }

    // Função para inicializar ou obter o gráfico
    function getChart() {
        if (!sensorChart) {
             const ctx = chartCanvas.getContext('2d');
             sensorChart = new Chart(ctx, {
                type: 'line', // Tipo de gráfico
                data: chartData,
                options: {
                    animation: false, // Desativa animações para performance
                    scales: {
                        y: { beginAtZero: true, max: 4095 }, // Eixo Y de 0 a 4095 (ADC 12 bits)
                        x: { type: 'linear', // Usando números no eixo X
                             ticks: { display: false } // Oculta labels do eixo X
                           }
                    },
                    maintainAspectRatio: false // Permite controlar altura/largura via CSS/div
                }
            });
        }
        return sensorChart;
    }

    // Função para adicionar UMA amostra (6 gates + tempo) ao gráfico
    function addSingleSampleToChart(sampleData) { // Recebe [s1, s2, s3, s4, s5, s6, t1]
        const chart = getChart();
        const timeSeconds = sampleData[6] / 1000.0; // Usa o timestamp da ESP32

        chart.data.labels.push(timeSeconds);
        for (let i = 0; i < 6; i++) {
            chart.data.datasets[i].data.push(sampleData[i]);
        }

        // Remove pontos antigos
        while (chart.data.labels.length > MAX_CHART_POINTS) {
            chart.data.labels.shift();
            chart.data.datasets.forEach(dataset => dataset.data.shift());
        }
    }

    function connectWebSocket() {
        if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) { return; }
        console.log(`Attempting to connect to ${socketUrl}...`);
        updateStatus("Connecting...", "connecting");
        connectButton.disabled = true; disconnectButton.disabled = true;
        socket = new WebSocket(socketUrl);
        socket.binaryType = "arraybuffer"; // Essencial!

        socket.onopen = (event) => { 
            console.log("WebSocket connection opened.");
            updateStatus("Connected", "connected");
            disconnectButton.disabled = false;
            receivedChunks = 0;
            dataOutputElem.innerHTML = "Connection established. Waiting for data...";

            // Reset the chart data using the safer getChart
            const chart = getChart(); // Chama getChart para garantir inicialização
            console.log("onopen: Attempting to reset chart. Chart object:", chart);

            if (chart && chart.data && chart.data.datasets) { // Verifica tudo
                console.log("onopen: Clearing labels and dataset data.");
                chart.data.labels = [];
                chart.data.datasets.forEach(dataset => {
                    dataset.data = []; // Limpa a array de dados de cada dataset
                });
                chart.update('none'); // Atualiza para mostrar vazio
                console.log("onopen: Chart reset complete.");
            } else {
                console.error("onopen: Failed to get valid chart object/data/datasets during reset! Data might not display.");
            }
        };

        socket.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
                const arrayBuffer = event.data;
                const receivedSize = arrayBuffer.byteLength;

                // Verifica se o tamanho recebido é múltiplo do tamanho do pacote individual
                if (receivedSize === 0 || receivedSize % SINGLE_PACKET_SIZE !== 0) {
                    console.warn(`Received data with unexpected size: ${receivedSize} bytes. Not a multiple of ${SINGLE_PACKET_SIZE}. Skipping.`);
                    return;
                }

                const numSamplesInChunk = receivedSize / SINGLE_PACKET_SIZE;
                const dataView = new DataView(arrayBuffer);
                let firstSampleData = null; // Para log
                let lastSampleData = null;  // Para log

                // Loop para processar cada pacote dentro do chunk recebido
                for (let i = 0; i < numSamplesInChunk; i++) {
                    const offset = i * SINGLE_PACKET_SIZE;

                    // Lê os dados do pacote atual
                    const s1 = dataView.getUint16(offset + 0, true);
                    const s2 = dataView.getUint16(offset + 2, true);
                    const s3 = dataView.getUint16(offset + 4, true);
                    const s4 = dataView.getUint16(offset + 6, true);
                    const s5 = dataView.getUint16(offset + 8, true);
                    const s6 = dataView.getUint16(offset + 10, true);
                    const t1 = dataView.getUint32(offset + 12, true);

                    // Guarda dados para log
                    const currentSample = [s1, s2, s3, s4, s5, s6, t1];
                    if (i === 0) {
                        firstSampleData = currentSample;
                    }
                    lastSampleData = currentSample; // Sempre atualiza para pegar o último

                    addSingleSampleToChart(currentSample);
                }

                // Log (apenas o primeiro e último pacote do chunk para não poluir)
                receivedChunks++;
                let logText = `Chunk ${receivedChunks} (${numSamplesInChunk} samples): `;
                if(firstSampleData) {
                     logText += `First[T=${(firstSampleData[6]/1000).toFixed(3)}s: ${firstSampleData.slice(0,6).join(',')}] `;
                }
                 if(numSamplesInChunk > 1 && lastSampleData) {
                     logText += `Last[T=${(lastSampleData[6]/1000).toFixed(3)}s: ${lastSampleData.slice(0,6).join(',')}]`;
                } else if (numSamplesInChunk === 1 && firstSampleData){
                    // Se só veio 1, já mostramos
                } else {
                    logText += "(Empty Chunk?)";
                }
                logData(logText);

                // Atualiza o gráfico UMA VEZ após processar todo o chunk
                getChart().update('none');

            } else {
                console.log("Received text message:", event.data);
                logData(`Received text: ${event.data}`);
            }
        };
    }

    function disconnectWebSocket() {
        if (socket && socket.readyState === WebSocket.OPEN) { socket.close(); }
        else {
             console.log("Socket not open or already closed.");
             updateStatus("Disconnected", "disconnected");
             connectButton.disabled = false; disconnectButton.disabled = true;
             socket = null;
        }
    }

    connectButton.addEventListener('click', connectWebSocket);
    disconnectButton.addEventListener('click', disconnectWebSocket);
    
</script>
</body>
</html>