<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 Control & Stream</title>

    <!-- Pico.css Framework via CDN (Minimalist styling) -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">

    <!-- Minimal custom CSS styles -->
    <style>
        /* General spacing and margins */
        body { 
            padding-top: 1.5rem; 
            padding-bottom: 3rem; 
            font-size: 15px; /* Slightly smaller base font for mobile friendliness */
        }
        main.container {
            padding-left: 0.75rem; /* Reduce padding on small screens */
            padding-right: 0.75rem;
        }
        main.container > *:not(:last-child) { 
            margin-bottom: 1.5rem; /* Space between sections */
        }
        /* Connection Status */
        #connectionStatus { 
            font-weight: bold; 
            margin-bottom: 0.5em; 
            padding: 0.5em;
            border-radius: var(--pico-border-radius);
            text-align: center;
        }
        /* Variables Table */
        table {
            font-size: 0.9em; /* Slightly smaller font for table content */
        }
        table th, table td {
            padding: 0.5rem 0.4rem; /* Reduce padding in table cells */
        }
        table input[type="text"], 
        table input[type="number"], 
        table button { 
            margin-bottom: 0; 
            font-size: 0.95em; /* Slightly smaller font for inputs/buttons in table */
            padding: 0.4em 0.6em; /* Adjust padding for smaller buttons */
        }
        .variable-actions { 
            display: flex;          
            gap: 0.3rem;          /* Reduced gap */
            align-items: center;  
            min-width: auto;     /* Remove min-width for flexibility */
            flex-wrap: wrap;     /* Allow items to wrap to next line */
        }
        .variable-actions input { 
            flex-grow: 1;         
            min-width: 80px; /* Ensure input is not too small */
            margin-top: 0.3rem; /* Add some space if it wraps */
        }
        .variable-actions .action-buttons { /* New wrapper for buttons */
            display: flex;
            gap: 0.3rem;
        }
        /* Stream Section */
        #streamStatusDisplay { 
            display: block; 
            margin-top: 0.75em; 
            font-size: 0.9em;
            color: var(--pico-muted-color); /* Softer color for status */
        }
        #binaryDataLogArea { 
            max-height: 250px;      /* Max height before scrolling */
            overflow-y: auto;       /* Add vertical scrollbar */
            background: #f7f8fa;    /* Subtle different background */
            padding: 1em;           /* Internal spacing */
            margin-top: 1em;        /* Space above the log */
            border: 1px solid var(--pico-form-element-border-color); 
            border-radius: var(--pico-border-radius);
            font-family: var(--pico-font-family-monospace); /* Monospaced font */
            font-size: 0.8em;       /* Smaller font size for log */
            line-height: 1.5;       /* Line spacing */
            white-space: pre;       /* Preserve spaces and line breaks */
            color: var(--pico-secondary-color); /* Log text color */
        }
        /* Section Headers */
         figure > header, article > header {
            font-size: 1.15em;
            font-weight: bold;
            padding-bottom: 0.6rem;
            border-bottom: 1px solid var(--pico-muted-border-color);
            margin-bottom: 1.2rem;
        }
        /* Visual busy indicator (aria-busy) */
        button[aria-busy="true"] {
            color: transparent !important; /* Hide text during 'busy' */
        }
        /* --- Responsive Adjustments for Smaller Screens --- */
        @media (max-width: 600px) { /* Breakpoint for small screens (e.g., mobile phones) */
            h1 {
                font-size: 1.5em; /* Smaller main title */
            }
            main.container {
                padding-left: 0.5rem; 
                padding-right: 0.5rem;
            }
            figure > header, article > header {
                font-size: 1.05em; /* Smaller section headers */
                margin-bottom: 0.8rem;
            }
            table {
                display: block; /* Change table to block for better overflow handling */
                width: 100%;
            }
            table thead {
                display: none; /* Hide table header on small screens (data implies meaning) */
            }
            table tbody, table tr, table td {
                display: block; /* Each cell becomes a block */
                width: 100% !important; /* Force full width */
                text-align: left !important; /* Align text to left for block display */
            }
            table td {
                padding-left: 0.5rem;
                padding-right: 0.5rem;
                border-bottom: 1px solid var(--pico-muted-border-color); /* Separator between "rows" */
            }
            table td:last-child {
                border-bottom: 2px solid var(--pico-primary-focus); /* Thicker border for last "row" (actions) */
                padding-bottom: 0.8rem; /* More space after actions */
            }
            /* Add labels before cell data using ::before pseudo-element */
            table td[data-label]::before {
                content: attr(data-label);
                font-weight: bold;
                display: inline-block;
                width: 100px; /* Adjust width as needed */
                margin-right: 10px;
                color: var(--pico-h5-color);
            }

            .variable-actions {
                flex-direction: column; /* Stack action items vertically */
                align-items: stretch;   /* Stretch items to full width */
                gap: 0.5rem;
            }
            .variable-actions input {
                width: 100%; /* Input takes full width */
                margin-top: 0; /* Reset margin-top */
                order: 1; /* Input appears first in vertical stack */
            }
            .variable-actions .action-buttons { /* Wrapper for Get/Set buttons */
                order: 2; /* Buttons appear after input */
                width: 100%;
                justify-content: space-around; /* Space out buttons */
            }
            .variable-actions .action-buttons button {
                flex-grow: 1; /* Allow buttons to grow */
            }
             #loadVarsConfigButton {
                width: 100%; /* Full width for the load config button */
            }
        }
    </style>
</head>

<body>
    <!-- Main Container -->
    <main class="container">

        <!-- Page Title -->
        <h1>ESP32 Control & Stream</h1>
        <div id="connectionStatus">Connecting...</div>

        <article>
            <header>Real-Time Stream</header>
            <div class="grid">
                <button id="startStreamButton" aria-busy="false">Start Stream</button>
                <button id="stopStreamButton" class="secondary" aria-busy="false" disabled>Stop Stream</button>
            </div>
            <small id="streamStatusDisplay">Stream stopped.</small>
            <pre id="binaryDataLogArea">(Stream data log will appear here)</pre>
        </article>

        <!-- Section: Configurable Variables (Get/Set) -->
        <figure>
            <header>Configurable Variables (Get/Set)</header>
            <button id="loadVarsConfigButton" style="margin-bottom: 1rem;" disabled>Load Variables Configuration from ESP32</button>
            
            <!-- Note: "overflow-auto" div is less critical if the table stacks vertically -->
            <div> 
                <table role="grid">
                    <thead>
                        <tr>
                            <th scope="col">Variable</th>
                            <th scope="col">Current Value</th>
                            <th scope="col">ESP32 Type</th>
                            <th scope="col">Actions (Get/Set)</th> 
                        </tr>
                    </thead>
                    <tbody id="variablesTableBody">
                        <tr><td colspan="4" style="text-align: center; color: grey;">Click "Load Variables Configuration..." or wait for connection.</td></tr>
                    </tbody>
                </table>
            </div>
        </figure>

        <!-- Informational Footer -->
        <footer>
            <hr>
            <small>Connect to the ESP32's Wi-Fi network (SSID: ESP32_Control_AP) and reload the page if needed.</small>
        </footer>

    </main> <!-- End of main container -->

    <!-- JavaScript Code -->
    <script>
        /** 
         * WebSocket Client Script for ESP32 Interaction
         * (Compatible with ApplicationDemo.ino and ESP32WebSocketControl)
         */

        // --- Essential Configuration ---
        const ESP32_STATIC_IP = "192.168.5.1"; // Static IP defined in ESP32WebSocketControl.cpp
        const WEBSOCKET_URL = `ws://${ESP32_STATIC_IP}/ws`;

        // --- Constants for Binary Data Processing (must match C++ struct) ---
        const SENSOR_PACKET_BYTES = 16; // Total size of SensorDataPacket (6*uint16 + 1*uint32)
        const SENSORS_PER_PACKET = 6;   // Number of sensor readings per packet

        // --- DOM Element References ---
        const connectionStatusEl = document.getElementById('connectionStatus');
        const variablesTableBodyEl = document.getElementById('variablesTableBody');
        const startStreamBtnEl = document.getElementById('startStreamButton');
        const stopStreamBtnEl = document.getElementById('stopStreamButton');
        const streamStatusDisplayEl = document.getElementById('streamStatusDisplay');
        const binaryDataLogAreaEl = document.getElementById('binaryDataLogArea');
        const loadVarsConfigBtnEl = document.getElementById('loadVarsConfigButton'); // New button element

        // --- Client State Variables ---
        let webSocketInstance;                  // Stores the WebSocket object instance
        let configurableVariablesData = {};     // Object to store current values of Get/Set variables
        let variablesConfiguration = {};        // Object to store detailed configuration (type, min, max) from ESP32
        let isClientStreaming = false;          // Flag indicating if client has requested/believes stream is active
        let binaryChunkCounter = 0;             // Counter for received binary chunks (messages)

        // --- WebSocket Functions ---

        /**
         * Establishes the WebSocket connection to the ESP32.
         */
        function connectWebSocket() {
            console.log(`Attempting to connect to WebSocket: ${WEBSOCKET_URL}`);
            updateConnectionStatus('Connecting...', 'orange');
            startStreamBtnEl.disabled = true; // Disable controls during connection attempt
            stopStreamBtnEl.disabled = true;
            loadVarsConfigBtnEl.disabled = true;

            webSocketInstance = new WebSocket(WEBSOCKET_URL);
            webSocketInstance.binaryType = "arraybuffer"; // Crucial for receiving binary data correctly

            // Callback: Connection Opened
            webSocketInstance.onopen = () => {
                console.log('WebSocket Connected!');
                updateConnectionStatus('Connected to ESP32', 'green');
                variablesTableBodyEl.innerHTML = '<tr><td colspan="4" style="text-align: center; color: grey;">Connected. Click "Load Variables Configuration..."</td></tr>'; 
                binaryChunkCounter = 0;
                isClientStreaming = false; 
                updateStreamControlUI();   
                loadVarsConfigBtnEl.disabled = false; // Enable button upon successful connection
                // Automatically load variable config on connect for convenience
                sendLoadVarsConfigRequest(); 
            };

            // Callback: Connection Closed
            webSocketInstance.onclose = (event) => {
                console.log(`WebSocket Disconnected. Code: ${event.code}, Reason: ${event.reason || 'N/A'}`);
                updateConnectionStatus(`Disconnected (Code: ${event.code})`, 'red');
                variablesTableBodyEl.innerHTML = '<tr style="color: red;"><td colspan="4">Connection lost. Reload the page.</td></tr>';
                isClientStreaming = false;
                updateStreamControlUI(); 
                loadVarsConfigBtnEl.disabled = true;
            };

            // Callback: Connection Error
            webSocketInstance.onerror = (error) => {
                console.error('WebSocket Error:', error);
                updateConnectionStatus('WebSocket Connection Error', 'red');
                variablesTableBodyEl.innerHTML = '<tr style="color: red;"><td colspan="4">Connection error. Check IP and ESP32.</td></tr>';
                isClientStreaming = false;
                updateStreamControlUI();
                loadVarsConfigBtnEl.disabled = true;
            };

            // Callback: Message Received from Server
            webSocketInstance.onmessage = (event) => {
                // Check the type of data received (Text JSON or Binary ArrayBuffer)
                if (event.data instanceof ArrayBuffer) {
                    binaryChunkCounter++; // Increment chunk counter
                    processBinaryData(event.data); // Process binary data
                    streamStatusDisplayEl.textContent = `Stream active. Chunks received: ${binaryChunkCounter}`; 
                } else if (typeof event.data === 'string') {
                    // Attempt to process as a JSON message
                    try {
                        const message = JSON.parse(event.data);
                        console.log('JSON Received:', message); 
                        
                        // Check if it's the variable configuration list from ESP32
                        if (message.status && message.status === "var_config_list" && message.variables) {
                            processVariablesConfiguration(message.variables);
                        }
                        // Check if it's a general status/confirmation message from ESP32
                        else if (message.status) { 
                           handleServerStatusMessage(message);
                        }
                        // Check if it's an update for a Get/Set variable
                        else if (message.variable !== undefined && message.value !== undefined) { 
                           handleVariableUpdateMessage(message);
                        } else {
                            console.warn("Received JSON in an unrecognized format:", message);
                        }
                    } catch (e) {
                        console.error('Error processing text message (Invalid JSON?):', e, event.data);
                        updateConnectionStatus('Error: Received invalid text data', 'orange');
                    }
                } else {
                     // Unexpected data type
                     console.warn("Unexpected WebSocket data type received:", typeof event.data, event.data);
                }
            };
        }

        // --- Received Message Handling Functions ---

        /**
         * Processes the list of variable configurations received from the ESP32.
         * Populates configurableVariablesData (current values) and variablesConfiguration (metadata).
         * @param {Array} varsArray Array of variable configuration objects from ESP32.
         */
        function processVariablesConfiguration(varsArray) {
            configurableVariablesData = {}; // Clear previous current values
            variablesConfiguration = {};    // Clear previous metadata

            varsArray.forEach(varConfig => {
                configurableVariablesData[varConfig.name] = varConfig.value; // Store current value
                variablesConfiguration[varConfig.name] = {                   // Store detailed configuration
                    type: varConfig.type, // ESP32 type: "INT", "FLOAT", "STRING"
                    hasLimits: varConfig.hasLimits,
                    min: varConfig.min,   // Undefined if no limits
                    max: varConfig.max    // Undefined if no limits
                };
            });
            console.log("Variable configuration received and processed:", variablesConfiguration);
            renderVariablesTable(); // Re-render the variables table with new data
            // Provide feedback to the user
            updateConnectionStatus('Variable configuration loaded.', 'green'); 
            setTimeout(() => { // Revert status after a short delay
                if (webSocketInstance && webSocketInstance.readyState === WebSocket.OPEN) {
                    updateConnectionStatus('Connected to ESP32', 'green');
                }
            }, 2500);
        }

        /**
         * Processes status messages sent by the ESP32 server.
         * Updates client-side stream state if message confirms start/stop.
         * @param {object} message JSON object with 'status' and 'message' fields.
         */
        function handleServerStatusMessage(message) {
            console.log(`ESP32 Status [${message.status}]: ${message.message}`);
            const msgText = message.message.toLowerCase();
            if (msgText.includes("stream iniciado") || msgText.includes("stream já estava ativo")) {
                isClientStreaming = true;
                if (msgText.includes("stream iniciado")) binaryChunkCounter = 0; 
            } else if (msgText.includes("stream parado") || msgText.includes("stream já estava parado")) {
                isClientStreaming = false;
            }
            updateStreamControlUI(); 
            if(message.status === 'error' && msgText.includes('definir valor')) {
                 renderVariablesTable(); 
            }
        }

        /**
         * Processes update messages for Get/Set variables.
         * Stores the new value and updates the HTML table.
         * @param {object} message JSON object with 'variable' and 'value' fields.
         */
        function handleVariableUpdateMessage(message) {
             configurableVariablesData[message.variable] = message.value; 
             renderVariablesTable(); 
        }

        /**
         * Processes received binary data (ArrayBuffer).
         * Decodes SensorDataPacket(s) and updates the binary data log area.
         * @param {ArrayBuffer} arrayBuffer Raw binary data.
         */
        function processBinaryData(arrayBuffer) {
            if (arrayBuffer.byteLength === 0 || arrayBuffer.byteLength % SENSOR_PACKET_BYTES !== 0) {
                console.error(`Binary Error: Buffer size (${arrayBuffer.byteLength}) invalid or not a multiple of ${SENSOR_PACKET_BYTES}.`);
                logToBinaryArea(`[Error: Invalid binary buffer received! Size: ${arrayBuffer.byteLength}]\n`);
                return;
            }
            const numPacketsInChunk = arrayBuffer.byteLength / SENSOR_PACKET_BYTES;
            const dataView = new DataView(arrayBuffer);
            let chunkLogContent = ""; 

            for (let i = 0; i < numPacketsInChunk; i++) {
                const offset = i * SENSOR_PACKET_BYTES; 
                const sensorReadings = []; 
                for(let s = 0; s < SENSORS_PER_PACKET; s++) {
                    sensorReadings.push(dataView.getUint16(offset + (s * 2), true)); // true for Little Endian
                }
                const timeMs = dataView.getUint32(offset + (SENSORS_PER_PACKET * 2), true); // true for Little Endian

                if (i === 0 || i === numPacketsInChunk - 1) { 
                   chunkLogContent += ` C${binaryChunkCounter} P${i}: [${sensorReadings.join(', ')}] @ ${timeMs}ms\n`;
                } else if (i === 1 && numPacketsInChunk > 2) { 
                    chunkLogContent += ` C${binaryChunkCounter} P${i}: ... (${numPacketsInChunk - 2} samples omitted) ...\n`;
                }
                // TODO: Add actual data processing here (e.g., plotting to a chart)
            }
            logToBinaryArea(chunkLogContent); 
        }

        // --- User Interface (UI) Update Functions ---

        /**
         * Updates the connection status element with text and color.
         * @param {string} text Text to display.
         * @param {string} color Background color ('green', 'orange', 'red', or CSS color).
         */
        function updateConnectionStatus(text, color = 'grey') {
            connectionStatusEl.textContent = text;
            connectionStatusEl.style.backgroundColor = 
                color === 'green' ? '#d1e7dd' : 
                color === 'red' ? '#f8d7da' : 
                color === 'orange' ? '#fff3cd' : 
                '#e2e3e5'; 
             connectionStatusEl.style.color = 
                color === 'green' ? '#0f5132' : 
                color === 'red' ? '#842029' : 
                color === 'orange' ? '#664d03' : 
                '#41464b'; 
        }

        /**
         * (Re)builds the HTML table for configurable Get/Set variables.
         * Uses `variablesConfiguration` to determine input types and limits.
         */
         function renderVariablesTable() {
            variablesTableBodyEl.innerHTML = ''; 
            const variableNames = Object.keys(configurableVariablesData).sort(); 

            if (variableNames.length === 0) {
                 variablesTableBodyEl.innerHTML = '<tr><td colspan="4" style="text-align: center; color: grey;">No variables loaded. Click "Load Variables Configuration...".</td></tr>';
                 return;
            }

            variableNames.forEach(varName => {
                const varValue = configurableVariablesData[varName];
                const varConfig = variablesConfiguration[varName] || {}; 
                const espVarType = varConfig.type || "UNKNOWN"; 
                
                const row = variablesTableBodyEl.insertRow(); 
                
                // Add data-label attributes for CSS ::before pseudo-elements on small screens
                const nameCell = row.insertCell();
                nameCell.setAttribute('data-label', 'Variable: ');
                nameCell.textContent = varName; 
                
                const valueCell = row.insertCell(); 
                valueCell.setAttribute('data-label', 'Value: ');
                valueCell.textContent = (espVarType === 'STRING') ? `"${varValue}"` : varValue; 
                valueCell.style.wordBreak = 'break-all';
                
                const typeCell = row.insertCell();
                typeCell.setAttribute('data-label', 'Type: ');
                typeCell.textContent = espVarType; 

                const actionsCell = row.insertCell();
                actionsCell.setAttribute('data-label', 'Actions: '); // Label for the whole action block
                actionsCell.classList.add('variable-actions'); 

                const input = document.createElement('input');
                // ... (input type, step, min, max logic as before) ...
                if (espVarType === "INT" || espVarType === "FLOAT") {
                    input.type = 'number';
                    if (espVarType === "FLOAT") input.step = 'any'; 
                    if (varConfig.hasLimits) { 
                        if (varConfig.min !== undefined) input.min = varConfig.min;
                        if (varConfig.max !== undefined) input.max = varConfig.max;
                    }
                } else { 
                    input.type = 'text';
                }
                input.id = `input-${varName}`; 
                input.placeholder = `New value`; 
                input.value = varValue; 

                // Create a div to wrap buttons for better flex control on mobile
                const buttonWrapper = document.createElement('div');
                buttonWrapper.classList.add('action-buttons');

                const getButton = document.createElement('button');
                getButton.textContent = 'Get'; // Consider "R" for Read on very small screens if needed
                getButton.classList.add('secondary', 'outline');
                getButton.onclick = () => sendGetVariableRequest(varName); 

                const setButton = document.createElement('button');
                setButton.textContent = 'Set'; // Consider "W" for Write
                setButton.onclick = () => sendSetVariableRequest(varName); 

                buttonWrapper.appendChild(getButton);
                buttonWrapper.appendChild(setButton);

                // Order of appending for mobile layout (input first, then buttons)
                actionsCell.appendChild(input); // Input will be order 1 via CSS
                actionsCell.appendChild(buttonWrapper); // Button wrapper will be order 2
            });
        }
        
        /**
         * Updates the stream control UI elements (buttons, status text).
         */
        function updateStreamControlUI() {
             streamStatusDisplayEl.textContent = isClientStreaming 
                 ? `Stream active. Chunks received: ${binaryChunkCounter}` 
                 : 'Stream stopped.';
             streamStatusDisplayEl.style.color = isClientStreaming ? 'var(--pico-color-green-600)' : 'var(--pico-muted-color)';
             const isConnected = webSocketInstance && webSocketInstance.readyState === WebSocket.OPEN;
             startStreamBtnEl.disabled = isClientStreaming || !isConnected;
             stopStreamBtnEl.disabled = !isClientStreaming || !isConnected;
             startStreamBtnEl.setAttribute('aria-busy', isConnected && isClientStreaming ? 'true' : 'false'); 
             stopStreamBtnEl.setAttribute('aria-busy', isConnected && !isClientStreaming ? 'true' : 'false'); 
             if (!isClientStreaming && binaryChunkCounter === 0) { 
                 // binaryDataLogAreaEl.textContent = "(Stream data log will appear here)\n"; 
             }
        }

        /**
         * Appends text to the binary data log area, limiting its total size.
         * @param {string} text Text to append.
         */
        function logToBinaryArea(text) {
            binaryDataLogAreaEl.textContent = text + binaryDataLogAreaEl.textContent.substring(0, 4000); 
        }

        // --- WebSocket Message Sending Functions ---

        /**
         * Helper function to send a JavaScript payload object as JSON via WebSocket.
         * @param {object} payload The JavaScript object to send.
         */
        function sendWebSocketPayload(payload) {
             if (webSocketInstance && webSocketInstance.readyState === WebSocket.OPEN) {
                const jsonPayload = JSON.stringify(payload); 
                console.log('Sending:', jsonPayload);
                webSocketInstance.send(jsonPayload); 
             } else {
                 console.warn('WebSocket is not open. Cannot send message.');
                 updateConnectionStatus('Error: WebSocket disconnected', 'red');
                 updateStreamControlUI(); 
             }
        }

        /** Sends a "get" request to retrieve the value of a variable. */
        function sendGetVariableRequest(variableName) { 
            sendWebSocketPayload({ action: 'get', variable: variableName }); 
        }

        /** Sends a "set" request to define the value of a variable, with client-side validation. */
        function sendSetVariableRequest(variableName) {
            const inputElement = document.getElementById(`input-${variableName}`);
            if (!inputElement) { console.error(`Input element not found for: input-${variableName}`); return; }
            
            let valueToSend = inputElement.value; 
            const varConfig = variablesConfiguration[variableName] || {};
            const espVarType = varConfig.type;

            if (espVarType === "INT" || espVarType === "FLOAT") {
                const numericValue = Number(valueToSend);
                if (isNaN(numericValue)) {
                    alert(`Invalid value ('${valueToSend}') for numeric variable '${variableName}'. Please enter a valid number.`); return; 
                }
                if (varConfig.hasLimits) { // Client-side pre-validation (ESP32 also validates)
                    if (varConfig.min !== undefined && numericValue < varConfig.min) {
                        alert(`Value ${numericValue} for '${variableName}' is less than the minimum allowed (${varConfig.min}).`); return;
                    }
                    if (varConfig.max !== undefined && numericValue > varConfig.max) {
                        alert(`Value ${numericValue} for '${variableName}' is greater than the maximum allowed (${varConfig.max}).`); return;
                    }
                }
                valueToSend = numericValue; 
            }
            sendWebSocketPayload({ action: 'set', variable: variableName, value: valueToSend });
        }

        /** Sends the "start_stream" command to the ESP32. */
        function sendStartStreamRequest() { 
            sendWebSocketPayload({ action: 'start_stream' }); 
            isClientStreaming = true; 
            binaryChunkCounter = 0; 
            binaryDataLogAreaEl.textContent = "(Waiting for stream data...)\n"; 
            updateStreamControlUI();
        }

        /** Sends the "stop_stream" command to the ESP32. */
        function sendStopStreamRequest() { 
            sendWebSocketPayload({ action: 'stop_stream' }); 
            isClientStreaming = false;
            updateStreamControlUI();
        }

        /** Sends the "get_all_vars_config" command to load all variable configurations. */
        function sendLoadVarsConfigRequest() {
            variablesTableBodyEl.innerHTML = '<tr><td colspan="4" style="text-align: center; color: grey;">Loading variable configuration from ESP32...</td></tr>';
            sendWebSocketPayload({ action: 'get_all_vars_config' });
        }

        // --- Script Initialization ---

        // Add an event listener to execute code when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM Loaded. Initializing WebSocket...');
            connectWebSocket(); // Attempt to connect when the page loads

            // Add click event listeners to control buttons
            startStreamBtnEl.addEventListener('click', sendStartStreamRequest);
            stopStreamBtnEl.addEventListener('click', sendStopStreamRequest);
            loadVarsConfigBtnEl.addEventListener('click', sendLoadVarsConfigRequest);
        });

    </script>
</body>
</html>